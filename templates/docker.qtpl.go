// This file is automatically generated by qtc from "docker.qtpl".
// See https://github.com/valyala/quicktemplate for details.

//line docker.qtpl:1
package templates

//line docker.qtpl:1
import (
	qtio422016 "io"

	qt422016 "github.com/valyala/quicktemplate"
)

//line docker.qtpl:1
var (
	_ = qtio422016.Copy
	_ = qt422016.AcquireByteBuffer
)

//line docker.qtpl:1
func StreamDocker(qw422016 *qt422016.Writer, id string) {
	//line docker.qtpl:1
	qw422016.N().S(`
<!doctype html>
<html>

<head>
    <script src="/static/js/hterm_all.js"></script>
    <style>
        #terminal {
            position: absolute;
            height: 90%;
            width: 90%;
        }
    </style>
</head>

<body>

    <div id="terminal"></div>

    <script>
        var socket = new WebSocket("ws://" + document.location.host + "/docker/`)
	//line docker.qtpl:21
	qw422016.E().S(id)
	//line docker.qtpl:21
	qw422016.N().S(`/ws");

        socket.onopen = function() {
            hterm.defaultStorage = new lib.Storage.Memory();
            var t = new hterm.Terminal();
            t.getPrefs().set("send-encoding", "raw");

            t.onTerminalReady = function() {

                // Create a new terminal IO object and give it the foreground.
                // (The default IO object just prints warning messages about unhandled
                // things to the the JS console.)
                var io = t.io.push();

                io.onVTKeystroke = function(str) {
                    // Do something useful with str here.
                    // For example, Secure Shell forwards the string onto the NaCl plugin.
                    socket.send(JSON.stringify(['stdin', str]));
                };

                io.sendString = io.onVTKeystroke;

                io.onTerminalResize = function(columns, rows) {
                    // React to size changes here.
                    // Secure Shell pokes at NaCl, which eventually results in
                    // some ioctls on the host.
                    socket.send(JSON.stringify(['set_size', rows, columns]));
                };

                // You can call io.push() to foreground a fresh io context, which can
                // be uses to give control of the terminal to something else.  When that
                // thing is complete, should call io.pop() to restore control to the
                // previous io object.
                t.installKeyboard();
            };

            t.decorate(document.querySelector('#terminal'));

            socket.addEventListener("message", function(ev) {
                var data = JSON.parse(ev.data)
                if (data[0] == "stdout") {
                    t.io.print(data[1]);
                }
                // console.log(data);
            });

            var onclose = function() {
                t.uninstallKeyboard();
                t.io.showOverlay("Connection closed", null);
            };

            socket.addEventListener("close", onclose);
            socket.addEventListener("error", onclose);
        };
    </script>

</body>

</html>
`)
//line docker.qtpl:80
}

//line docker.qtpl:80
func WriteDocker(qq422016 qtio422016.Writer, id string) {
	//line docker.qtpl:80
	qw422016 := qt422016.AcquireWriter(qq422016)
	//line docker.qtpl:80
	StreamDocker(qw422016, id)
	//line docker.qtpl:80
	qt422016.ReleaseWriter(qw422016)
//line docker.qtpl:80
}

//line docker.qtpl:80
func Docker(id string) string {
	//line docker.qtpl:80
	qb422016 := qt422016.AcquireByteBuffer()
	//line docker.qtpl:80
	WriteDocker(qb422016, id)
	//line docker.qtpl:80
	qs422016 := string(qb422016.B)
	//line docker.qtpl:80
	qt422016.ReleaseByteBuffer(qb422016)
	//line docker.qtpl:80
	return qs422016
//line docker.qtpl:80
}
